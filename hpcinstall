#!/usr/bin/env python
import argparse, os, stat, shutil, sys, subprocess, yaml, datetime, re
import tee, hashdir

pass_env = ("env HPCI_SW_DIR=%(SW_DIR)s " +         # the "s" is crucial (!!)
            "HPCI_SW_NAME=%(SW_NAME)s " +
            "HPCI_SW_VERSION=%(SW_VERSION)s " +
            "HPCI_MOD_DIR=%(MOD_DIR)s ")

files_to_archive = []                               # logs and other files to preserve
HPCi_log = "hpci.main.log"
env_log = "hpci.env.log"
module_log = "hpci.modules.log"
list_of_dirs =['scratch_tree', 'sw_install_dir', 'mod_install_dir' ]

def print_invocation_info():
    if os.environ['USER'] == "csgteam":
        running_user = "csgteam (invoked by " + os.environ['SUDO_USER'] + ")"
    else:
        running_user = os.environ['USER']
    print "On", datetime.datetime.now().isoformat(), running_user
    print "called HPCinstall from", os.path.realpath(__file__)
    print "invoked as",
    simple = True
    for arg in sys.argv:
        if " " in arg or "'" in arg or '"' in arg or "\\" in arg:
            simple = False
    if simple:
        print " ".join(sys.argv)
    else:
        print sys.argv
    print # emtpy line

def parse_config_data(yaml_data):
    default_dirs = {}
    config = yaml.safe_load(yaml_data)
    if not config:
        raise KeyError(list_of_dirs)
    for dirname in list_of_dirs:
        default_dirs[dirname] = os.path.abspath(os.path.expanduser(config[dirname])) + "/"
    return default_dirs

def parse_installscript_filename(filename):
    sw_structure = filename.split("-")
    if len(sw_structure) !=3:
        print >> sys.stderr, "The software name and version must be specified as <build-software-version>. Got '" + filename + "' instead."
        if len(sw_structure) == 2:
            print >> sys.stderr, "Maybe you meant build-" + filename +"?"
        sys.exit(1)
    try:
        version = int(sw_structure[2].replace(".", ""))
        if version < 0:
            raise ValueError()
    except ValueError:
        print >> sys.stderr, "The software name and version must be specified as <build-software-version>. Got '" + filename + "' instead."
        print >> sys.stderr, "The version must be in i[.j[.k[...]]] format"
        sys.exit(1)
    return sw_structure[1] + "/" + sw_structure[2]

def validate_url(u):
    # cut and paste from django with localhost removed, no test needed
    regex = re.compile(
        r'^(?:http|ftp)s?://' # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|' #domain...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})' # ...or ip
        r'(?::\d+)?' # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    return regex.match(u)

def parse_command_line_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument("install_script", metavar="install-software-ver", type=argparse.FileType('r'),
                                                               help="script in the current directory which\n" +
                                                                    "                 does the build and install (do not use\n" +
                                                                    "                 './', relative nor fully qualified paths)")
    parser.add_argument("-c", "--csgteam", action="store_true", default=False, help='Install as csgteam (default: False)')
    parser.add_argument("-f", "--force", action="store_true", default=False, help='Force overwrite of existing install (default: False)')
    parser.add_argument("-d", "--debug", action="store_true", default=False, help='Debug mode i.e. more verbose output (default: False)')
    source_code = parser.add_mutually_exclusive_group(required=True)
    source_code.add_argument("-a", "--archive", action='append', nargs='*', type=argparse.FileType('r'), help='Store the provided source archive(s)')
    source_code.add_argument("-l", "--archive-list", action='append', nargs='*', metavar='FILE', type=argparse.FileType('r'), help='Store the source archive(s) provided in FILE')
    source_code.add_argument("-u", "--archive-url", action='append', nargs='*', metavar='URL', help='Store URL instead of source archive')
    parser.add_argument("--nossh", action="store_true", default=False, help=argparse.SUPPRESS) # Don't manually invoke this

    try:
        args = parser.parse_args()
    except IOError, e:
        print >> sys.stderr, "Troubles accessing <install-software-ver> file"
        print >> sys.stderr, e
        print
        parser.print_help()
        sys.exit(1)
    args.archive      = hashdir.flatten_argument(args.archive)
    args.archive_list = hashdir.flatten_argument(args.archive_list)
    args.archive_url  = hashdir.flatten_argument(args.archive_url)
    should_exit = False
    if args.archive_list:
        list_of_files = []
        for f in args.archive_list:
            for line in f:
                archive_file = os.path.abspath(os.path.expanduser(line.strip()))
                if not os.access(archive_file, os.R_OK):
                    print >> sys.stderr, "Troubles opening file", line.strip(), "specified in", f.name
                    should_exit = True
                else:
                    list_of_files.append(archive_file)
        args.archive_list = list_of_files
    if args.archive_url:
        for u in args.archive_url:
            if not validate_url(u):
                print >> sys.stderr, "Not a valid URL", u
                should_exit = True
    if should_exit:
        parser.print_help()
        sys.exit(1)
    return args

def ask_confirmation_for(options, msg):
    if options.csgteam:
        print msg,
        answer = sys.stdin.readline()
        print
        if answer.lower().strip() != "yes":
            print >> sys.stderr, "You did not say an ethusiastic 'yes', aborting..."
            sys.exit(1)

def get_prefix_and_moduledir(options, my_path, default_dirs):
    if options.csgteam:
        if os.environ['USER'] != "csgteam":
            ask_confirmation_for(options, "Should sudo into 'csgteam' to install as such. Continue anyway? ")
        prefix     = default_dirs["sw_install_dir"]  + my_path
        moduledir = default_dirs["mod_install_dir"]
    else:
        if "INSTALL_TEST_BASEPATH" in os.environ:
            basepath = os.environ['INSTALL_TEST_BASEPATH']
        else:
            basepath = default_dirs["scratch_tree"] + os.environ['USER'] + "/test_installs/"
        prefix = basepath + "/" + my_path
        moduledir = basepath + "/modulefiles/"

    if os.path.exists(prefix) and not options.force:
        print >> sys.stderr, "File already exists", prefix
        sys.exit(1)
    return os.path.abspath(prefix) + "/", os.path.abspath(moduledir) + "/"

def justify(stuff):
    max_len = 0
    for line in stuff.split("\n"):
        left = line.split("=")[0]
        max_len = max(max_len, len(left))

    new_stuff = ""
    for line in stuff.split("\n"):
        to_be_added = max_len - len(line.split("=")[0]) + 1
        new_line = line.replace("=", " " * to_be_added + "= ")
        new_stuff += new_line + "\n"
    return new_stuff

def prepare_variables_and_warn(prefix, moduledir, options):
    name = options.install_script.name.split("-")[1]       # 0 is build, 1 is software name
    version = options.install_script.name.split("-")[2]    # 2 is software version

    variables = {'SW_DIR': prefix,
                 'SW_NAME': name,
                 'SW_VERSION': version,
                 'MOD_DIR': moduledir,
                 # if adding more, need to pass them in the environment at the beginning of this script
                 }

    print "Setting environmental variables:"
    env_settings = (pass_env.replace(" ", "\n") % variables).replace("env\n", "")
    print justify(env_settings)
    ask_confirmation_for(options, "This will attempt global install in " + prefix +
                         " by running ./" + options.install_script.name + " as " + os.environ['USER'] + ". Continue? ")
    return variables

real_stdout = None
def redirect_output(log):
    global real_stdout
    if real_stdout == None:
        real_stdout = sys.stdout
    sys.stdout = open(log, 'w')

def restore_output():
    if not real_stdout == None:
        sys.stdout = real_stdout

def start_logging_current_session(log=HPCi_log, continuation=False):
    if continuation:
        tee.append_out_to(log)
    else:
        tee.overwrite_out_to(log)
        files_to_archive.append(log)
def stop_logging_current_session():
    tee.close_all_files()

def _subcall_helper(modules_to_load, command, variables, log):
    shell = os.environ['SHELL']
    if "bash" in shell:
        shell += " -l"    # bash needs to be forced login, otherwise not setting proper env
    shell += " -c "       # all shells need to be asked to run commands
    str_cmd = ('ssh -t localhost "' +     # to reset environment
               shell + "'ml purge; cd " + # remove all modules
               os.getcwd() + "; " +       # **not** where this script resides
               modules_to_load + " ")     # load specified modules
    if variables:
        str_cmd += pass_env % variables
    str_cmd += command + "'\""
    if log:
        str_cmd += " &> " + log
    return str_cmd

def subcall(modules_to_load, command, log=None, use_popen = False, variables = False, debug=False):
    str_cmd = _subcall_helper(modules_to_load, command, variables, log)
    if debug:
        print >> sys.stderr, "DEBUG:", str_cmd
    if use_popen:
        return subprocess.Popen(str_cmd, stderr=subprocess.STDOUT, stdout = subprocess.PIPE, shell=True)
    else:
        return subprocess.call(str_cmd, shell=True)

def log_full_env(modules_to_load):
    print "Saving environment status in", env_log, "...",
    subcall(modules_to_load, "env", env_log)
    print "Done."
    files_to_archive.append(env_log)

    print "Saving module list in", module_log, "...",
    subcall(modules_to_load, "module list", module_log)
    print "Done.\n"
    files_to_archive.append(module_log)

def string_or_file(stuff):
    try:
        lines = stuff.splitlines(True)   # a string
    except AttributeError:
        lines = stuff                    # a file
    return lines

def identify_compiler_mpi():
    compiler = os.environ.get('LMOD_FAMILY_COMPILER','').strip()
    mpi = ""
    try:
        if compiler:
            compiler += "/" + os.environ['LMOD_COMPILER_VERSION'].strip()
            mpi = os.environ.get('LMOD_FAMILY_MPI','').strip()
            if mpi:
                mpi = "/" + mpi + "/" + os.environ['LMOD_MPI_VERSION'].strip()
    except KeyError, ke:
        for broken_key in ke.args:
            print >> sys.stderr, "Error:", broken_key, "not set"
        sys.exit(1)
    return compiler + mpi

def parse_installscript_for_modules(install_script):
    executing_lines = []
    for line in string_or_file(install_script):
        if line.startswith("#HPCI "):
            exe_line = line.replace("#HPCI ", "", 1).split(" #")[0].strip()
            executing_lines.append(exe_line)
    modules_to_run = "; ".join(executing_lines)
    if len(modules_to_run) > 0:
        modules_to_run += ";"
    return modules_to_run

def verify_modules_are_loadable(modules_to_load, installscript_name):
    if (subcall(modules_to_load, "") != 0):
        print >> sys.stderr, "Modules from", installscript_name, "are not loadable:"
        print >> sys.stderr, modules_to_load
        sys.exit(1)

def execute_installscript(options, modules_to_load, variables):
    current_perm = os.stat(options.install_script.name)
    os.chmod(options.install_script.name, current_perm.st_mode | stat.S_IEXEC)
    print "Running ./" + options.install_script.name, "..."
    stop_logging_current_session()                                  # log the output of the script in a different dir
    log = "hpci." + options.install_script.name  + "-" + str(os.getpid()) + ".log"
    start_logging_current_session(log=log)
    p = subcall(modules_to_load, "./" + options.install_script.name, use_popen=True, variables=variables, debug=options.debug)
    process_output = " "
    while process_output != "":               # continue while the process is running, it'll be "" when EOF is reached
        process_output = p.stdout.readline()  # needs to do this instead of using subprocess.call to allow 
        print process_output,                 # 'tee' to log the process output
    p.poll()
    stop_logging_current_session()
    files_to_archive.append(log)
    start_logging_current_session(continuation=True)
    print "Done running ./" + options.install_script.name, "- exited with code", p.returncode
    files_to_archive.append(options.install_script.name)

def archive_in(prefix):
    build_dir = prefix + "/BUILD_DIR/"
    if not os.path.exists(build_dir):
    	os.makedirs(build_dir)
    for somefile in files_to_archive:
    	shutil.copyfile(somefile, build_dir + os.path.basename(somefile))

def how_to_call_yourself(args, yourself, pwd):
    shell = [os.environ['SHELL']]
    if "bash" in shell[0]:
        shell.append('-l')
    shell.append('-c')
    new_invocation = ['ssh', '-t', 'localhost']
    new_invocation += shell
    args_copy = list(args)
    args_copy[0] = os.path.abspath(yourself + "/hpcinstall")
    args_copy.append("--nossh")
    new_invocation.append("'" + "ml purge; cd " + pwd + "; " +
                                " ".join(args_copy) +
                          "'")
    return new_invocation

# execution starts here
if __name__ == "__main__":
    options = parse_command_line_arguments()
    script_dir = os.path.dirname(os.path.realpath(__file__)) # directory where this script is
    if not options.nossh:
        subprocess.call(how_to_call_yourself(sys.argv, script_dir, os.getcwd()))
        sys.exit(0)

    config_filename = ( os.path.dirname(os.path.realpath(__file__)) + # directory where this script is
                        "/config.hpcinstall.yaml" )
    try:
        defaults = parse_config_data(open(config_filename))
    except KeyError:
        print >> sys.stderr, "Error:", config_filename, "does not contain the expected fields", list_of_dirs
        sys.exit(1)
    except IOError as e:
        print >> sys.stderr, e
        print >> sys.stderr, "Cannot set", list_of_dirs, "-- ABORTING"
        sys.exit(1)
    my_program = parse_installscript_filename(options.install_script.name)
    modules_to_load = parse_installscript_for_modules(options.install_script)
    verify_modules_are_loadable(modules_to_load, options.install_script.name)
    log_full_env(modules_to_load)
    comp_mpi = identify_compiler_mpi()
    prefix, moduledir = get_prefix_and_moduledir(options, my_program + "/" + comp_mpi, defaults)
    if not moduledir in os.environ['MODULEPATH']:
        # run 'module use' on this directory, but only if needed
        modules_to_load = "module use " + moduledir + "; " + modules_to_load
    start_logging_current_session()
    print_invocation_info()
    variables = prepare_variables_and_warn(prefix, moduledir, options)
    execute_installscript(options, modules_to_load, variables)
    if options.archive:
        for tarball in options.archive:
            files_to_archive.append(tarball.name)
            print "Storing source archive", tarball.name
    if options.archive_list:
        for f in options.archive_list:
            files_to_archive.append(f)
            print "Storing source archive", f
    if options.archive_url:
        for u in options.archive_url:
            print "Not storing source archive, see instead", u
    print hashdir.hashdir(prefix), os.path.abspath(os.path.expanduser(prefix))
    stop_logging_current_session()
    hashlog = "hpci.fileinfo.log"
    redirect_output(hashlog)
    hashdir.hashdir(prefix, verbose=True)
    restore_output()
    files_to_archive.append(hashlog)
    archive_in(prefix)
