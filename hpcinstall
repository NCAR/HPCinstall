#!/bin/env python

import optparse # cruder than others, but compatible with older versions of python
import os, shutil, sys, subprocess
import tee

use_parent_shell = os.environ['SHELL'] + " -c "    # workaround for fixing tcsh module problem, see https://github.com/NCAR/HPCinstall/issues/6
files_to_archive = [os.path.realpath(__file__)]    # logs and other files to preserve

def separator(msg=""):
    print msg.center(80,"-")

def parse_installscript_filename(filename):
    sw_structure = filename.split("-")
    if len(sw_structure) !=2 and len(sw_structure) !=4:
        print "The install script file should be named like <software-version-compiler-version>,"
        print "or <software-version>. Got '" + filename + "' instead"
        sys.exit(1)
    my_compiler = ""
    if len(sw_structure) == 4:
        my_compiler = sw_structure[2] + "/" + sw_structure[3]
    return my_compiler, sw_structure[0] + "/" + sw_structure[1]

def parse_command_line_arguments():
    usage = ("usage: %prog [options] <software-version-compiler-version>\n" +
             "Required:\n" +
             "  <software-ver-compiler-ver> script in the current directory\n" +
             "                              doing the build and install\n" +
             "                              (don't use '/' or fully qualified paths)")
    parser = optparse.OptionParser(usage)
    parser.add_option("-c", "--csgteam", action="store_true", default=False, help='Install as csgteam (default: False)')
    (options, args) = parser.parse_args()
    if len(args) != 1:
        parser.print_help()
        sys.exit(1)
    install_script = args[0]
    if not os.path.isfile(install_script) or "/" in install_script:
        parser.print_help()
        sys.exit(1)
    return install_script, options

def ask_confirmation_for(options, msg):
    if options.csgteam:
        print msg,
        answer = sys.stdin.readline()
        print
        if answer.lower().strip() != "yes":
            print "You did not say an ethusiastic 'yes', aborting..."
            sys.exit(1)

def get_variables(options, my_program, my_compiler):
    if options.csgteam:
        if os.environ['USER'] != "csgteam":
            ask_confirmation_for(options, "Should sudo into 'csgteam' to install as such. Continue anyway? ")
        prefix = "/glade/apps/opt/" + my_program + "/" + my_compiler
        modulefile = "/glade/apps/modulefiles/" + my_program + ".lua"
    else:
        prefix = "/glade/scratch/" + os.environ['USER'] + "/" + my_program + "/" + my_compiler
        modulefile = "/glade/scratch/modulefiles/" + my_program + ".lua"

    if os.path.exists(prefix):
        print "File already exists", prefix
        sys.exit(1)
    if os.path.exists(modulefile):
        print "File already exists", prefix
        sys.exit(1)
    return prefix, modulefile

def set_variables_and_warn(prefix, modulefile, options, install_script):
    print "Setting environmental variables:"
    print "INSTALL_DIR     =", prefix
    print "MODULE_FILENAME =", modulefile
    print
    ask_confirmation_for(options, "This will attempt global install in " + prefix + 
                         " by running ./" + install_script + " as " + os.environ['USER'] + ". Continue? ")
    os.environ['INSTALL_DIR'] = prefix
    os.environ['MODULE_FILENAME'] = modulefile

def start_logging_current_session():
    log = "log.hpcinstall." + str(os.getpid()) + ".txt"
    tee.overwrite_out_to(log)
    files_to_archive.append(log)
def stop_logging_current_session():
    tee.close_all_files()

def subcall(modules_to_load, command, log=None, use_popen = False):
    str_cmd = use_parent_shell + "'" + modules_to_load + "; " + command + "'"
    if log:
        str_cmd += " &> " + log
    if use_popen:
        return subprocess.Popen(str_cmd, stderr=subprocess.STDOUT, stdout = subprocess.PIPE, shell=True)
    else:
        return subprocess.call(str_cmd, shell=True)

def log_full_env(modules_to_load):
    env_log = "log.env.txt"
    print "Saving environment status in", env_log, "...",
    subcall(modules_to_load, "env", env_log)
    print "Done."
    files_to_archive.append(env_log)

    module_log = "log.modules.txt"
    print "Saving module list in", module_log, "...",
    subcall(modules_to_load, "module list", module_log)
    print "Done.\n"
    files_to_archive.append(module_log)

def parse_installscript_for_modules(install_script):
    warning = ""
    executing_lines = []
    for line in open(install_script):
        if "module" in line or "ml" in line:
            if line.startswith("#"):
                exe_line = line.replace("#", "", 1).strip()
                executing_lines.append(exe_line)
            else:
                warning += line
    if warning != "":
        separator(" POSSIBLY PROBLEMATIC COMMANDS IN ./" + install_script + " ")
        print warning,
        separator()
        ask_confirmation_for(options, "Would you like to run anyway? ")
    if len(executing_lines) > 0:
        separator(" MODULE COMMANDS THAT WILL BE EXECUTED ")
        for l in executing_lines: print l
        separator()
    return "; ".join(executing_lines)

def execute_installscript(modules_to_load, install_script):
    separator(" LOG of EXECUTING ./" + install_script + " ")
    p = subcall(modules_to_load, "./" + install_script, use_popen=True)
    process_output = " "
    while process_output != "":               # continue while the process is running, it'll be "" when EOF is reached
        process_output = p.stdout.readline()  # needs to do this instead of using subprocess.call to allow 
        print process_output,                 # 'tee' to log the process output
    p.poll()
    separator()
    print "./" + install_script, "completed and exit with code", p.returncode

def archive_in(prefix):
    build_dir = prefix + "/BUILD_DIR/"
    os.makedirs(build_dir)
    for somefile in files_to_archive:
        shutil.copyfile(somefile, build_dir + os.path.basename(somefile))

# execution starts here
install_script, options = parse_command_line_arguments()
my_compiler, my_program = parse_installscript_filename(install_script)
prefix, modulefile = get_variables(options, my_program, my_compiler)
start_logging_current_session()
set_variables_and_warn(prefix, modulefile, options, install_script)
modules_to_load = parse_installscript_for_modules(install_script)
log_full_env(modules_to_load)
execute_installscript(modules_to_load, install_script)
stop_logging_current_session()
archive_in(prefix)
