#!/usr/bin/env python

import optparse # cruder than others, but compatible with older versions of python
import os, stat, shutil, sys, subprocess, yaml, datetime
import tee

compiler_modules = ["gnu", "intel", "pgi", "pathscale", "pgi", "cuda", "sun"]

current_directory = os.getcwd()                     # not necessarily where this script resides
use_ssh = "ssh -t localhost 'ml purge; cd " + current_directory + "; "
pass_env = ("env HPCI_SW_DIR=%(SW_DIR)s " +         # the "s" is crucial (!!)
            "HPCI_SW_NAME=%(SW_NAME)s " +
            "HPCI_SW_VERSION=%(SW_VERSION)s " +
            "HPCI_MOD_DIR=%(MOD_DIR)s ")

files_to_archive = []                               # logs and other files to preserve
files_to_archive.append(os.path.realpath(__file__)) # preserve this script which is running
HPCi_log = "hpci.main.log"
default_dirs = {}                                  # just make it global

def parse_config_file():
    config_filename = ( os.path.dirname(os.path.realpath(__file__)) + # directory where this script is
                        "/config.hpcinstall.yaml" )
    list_of_dirs =['scratch_tree', 'sw_install_dir', 'mod_install_dir' ]
    try:
        config = yaml.safe_load(open(config_filename))
        if not config:
            raise AttributeError()
        for dirname in list_of_dirs:
            default_dirs[dirname] = config[dirname] + "/"
    except KeyError:
        print >> sys.stderr, "Error:", config_filename, "does not contain the expected fields", list_of_dirs
        sys.exit(1)
    except IOError as e:
        print >> sys.stderr, e
        print >> sys.stderr, "Cannot set", list_of_dirs, "-- ABORTING"
        sys.exit(1)

def separator(msg=""):
    print msg.center(80,"-")

def parse_installscript_filename(filename):
    sw_structure = filename.split("-")
    if len(sw_structure) !=3:
        print "The software name and version must be specified as <build-software-version>. Got '" + filename + "' instead."
        if len(sw_structure) == 2:
            print "Maybe you meant build-" + filename +"?"
        sys.exit(1)
    return sw_structure[1] + "/" + sw_structure[2]

def parse_command_line_arguments():
    usage = ("usage: %prog [options] <software-version>\n" +
             "Required:\n" +
             "  <software-ver> script in the current directory which\n" +
             "                 does the build and install (do not use\n" +
             "                 './', relative nor fully qualified paths)")
    parser = optparse.OptionParser(usage)
    parser.add_option("-c", "--csgteam", action="store_true", default=False, help='Install as csgteam (default: False)')
    parser.add_option("-f", "--force", action="store_true", default=False, help='Force overwrite of existing install (default: False)')
    parser.add_option("-d", "--debug", action="store_true", default=False, help='Debug mode i.e. more verbose output (default: False)')
    (options, args) = parser.parse_args()
    if len(args) != 1:
        parser.print_help()
        sys.exit(1)
    install_script = args[0]
    if not os.path.isfile(install_script) or "/" in install_script:
        parser.print_help()
        sys.exit(1)
    return install_script, options

def ask_confirmation_for(options, msg):
    if options.csgteam:
        print msg,
        answer = sys.stdin.readline()
        print
        if answer.lower().strip() != "yes":
            print "You did not say an ethusiastic 'yes', aborting..."
            sys.exit(1)

def get_variables(options, my_program, my_compiler):
    if options.csgteam:
        if os.environ['USER'] != "csgteam":
            ask_confirmation_for(options, "Should sudo into 'csgteam' to install as such. Continue anyway? ")
        prefix     = default_dirs["sw_install_dir"]  + my_program + "/" + my_compiler
        moduledir = default_dirs["mod_install_dir"]
    else:
        if "INSTALL_TEST_BASEPATH" in os.environ:
            basepath = os.environ['INSTALL_TEST_BASEPATH']
        else:
            basepath = default_dirs["scratch_tree"] + os.environ['USER'] + "/test_installs/"
        prefix = basepath + "/" + my_program + "/" + my_compiler
        moduledir = basepath + "/modulefiles/"

    if os.path.exists(prefix) and not options.force:
        print "File already exists", prefix
        sys.exit(1)
    return prefix, moduledir

def prepare_variables_and_warn(prefix, moduledir, options, install_script):
    name = install_script.split("-")[1]       # 0 is build, 1 is software name
    version = install_script.split("-")[2]    # 2 is software version
    print "Setting environmental variables:"
    print "HPCI_SW_DIR     =", prefix
    print "HPCI_SW_NAME    =", name
    print "HPCI_SW_VERSION =", version
    print "HPCI_MOD_DIR    =", moduledir
    # if adding more, need to pass them in the environment at the beginning of this script
    print
    ask_confirmation_for(options, "This will attempt global install in " + prefix + 
                         " by running ./" + install_script + " as " + os.environ['USER'] + ". Continue? ")

    variables = {'SW_DIR': prefix,
                 'SW_NAME': name,
                 'SW_VERSION': version,
                 'MOD_DIR': moduledir,
                 # if adding more, need to pass them in the environment at the beginning of this script
                 }
    return variables

def start_logging_current_session(log=HPCi_log, continuation=False):
    if continuation:
        tee.append_out_to(log)
    else:
        tee.overwrite_out_to(log)
        files_to_archive.append(log)
def stop_logging_current_session():
    tee.close_all_files()

def subcall(modules_to_load, command, log=None, use_popen = False, variables = False, debug=False):
    str_cmd = use_ssh + modules_to_load
    if variables:
        str_cmd += pass_env % variables
    str_cmd += command + "'"
    if log:
        str_cmd += " &> " + log
    if debug:
        print str_cmd
    if use_popen:
        return subprocess.Popen(str_cmd, stderr=subprocess.STDOUT, stdout = subprocess.PIPE, shell=True)
    else:
        return subprocess.call(str_cmd, shell=True)

def parse_compiler_and_log_full_env(modules_to_load):
    env_log = "hpci.env.log"
    print "Saving environment status in", env_log, "...",
    subcall(modules_to_load, "env", env_log)
    print "Done."
    files_to_archive.append(env_log)

    module_log = "hpci.modules.log"
    print "Saving module list in", module_log, "...",
    subcall(modules_to_load, "module list", module_log)
    print "Done.\n"
    loaded_compiler = []
    files_to_archive.append(module_log)
    for line in open(module_log):
        for c in compiler_modules:
            if c in line:
                for single_module in line.split():
                    if single_module.startswith(c + "/"):
                        loaded_compiler.append(single_module)
    compiler = ""
    if len(loaded_compiler) == 1:
        compiler = loaded_compiler[0]
    elif len(loaded_compiler) > 1:
        compiler = loaded_compiler[0]
        print "Warning, more than one compiler found:", loaded_compiler, "-- Using only the first."
    return compiler

def parse_installscript_for_modules(install_script):
    warning = ""
    executing_lines = []
    for line in open(install_script):
        if line.startswith("#HPCI "):
            exe_line = line.replace("#HPCI ", "", 1).strip()
            executing_lines.append(exe_line)
    modules_to_run = "; ".join(executing_lines)
    if len(modules_to_run) > 0:
        modules_to_run += "; "
    return modules_to_run

def execute_installscript(modules_to_load, install_script, variables, debug=False):
    current_perm = os.stat(install_script)
    os.chmod(install_script, current_perm.st_mode | stat.S_IEXEC)
    print "Running ./" + install_script, "..."
    stop_logging_current_session()                                  # log the output of the script in a different dir
    log = "hpci." + install_script  + "-" + str(os.getpid()) + ".log"
    start_logging_current_session(log=log)
    p = subcall(modules_to_load, "./" + install_script, use_popen=True, variables=variables, debug=debug)
    process_output = " "
    while process_output != "":               # continue while the process is running, it'll be "" when EOF is reached
        process_output = p.stdout.readline()  # needs to do this instead of using subprocess.call to allow 
        print process_output,                 # 'tee' to log the process output
    p.poll()
    stop_logging_current_session()
    files_to_archive.append(log)
    start_logging_current_session(continuation=True)
    print "Done running ./" + install_script, "- exited with code", p.returncode
    files_to_archive.append(install_script)

def archive_in(prefix):
    build_dir = prefix + "/BUILD_DIR/"
    if not os.path.exists(build_dir):
    	os.makedirs(build_dir)
    for somefile in files_to_archive:
    	shutil.copyfile(somefile, build_dir + os.path.basename(somefile))

# execution starts here
parse_config_file()
install_script, options = parse_command_line_arguments()
my_program = parse_installscript_filename(install_script)
modules_to_load = parse_installscript_for_modules(install_script)
my_compiler = parse_compiler_and_log_full_env(modules_to_load)
prefix, moduledir = get_variables(options, my_program, my_compiler)
if not moduledir in os.environ['MODULEPATH']:
    # run 'module use' on this directory, but only if needed
    modules_to_load = "module use " + moduledir + "; " + modules_to_load
start_logging_current_session()
if os.environ['USER'] == "csgteam":
    running_user = "csgteam (invoked by " + os.environ['SUDO_USER'] + ")"
else:
    running_user = os.environ['USER']
print "On", datetime.datetime.now().isoformat(), running_user
print "called HPCinstall as", os.path.realpath(__file__), "\n"
variables = prepare_variables_and_warn(prefix, moduledir, options, install_script)
execute_installscript(modules_to_load, install_script, variables, options.debug)
stop_logging_current_session()
archive_in(prefix)
